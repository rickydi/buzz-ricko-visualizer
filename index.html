<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BUZZ RICKO Visualizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; outline: none; }
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        body { 
            width: 100%; 
            height: 100%; 
            margin: 0;
            padding: 0;
            overflow: hidden; 
            background: #000; 
            font-family: 'Courier New', monospace; 
            position: fixed; /* Empêche le scroll élastique sur mobile */
        }
        #canvas-container { 
            width: 100%; 
            height: 100%; 
            position: fixed; 
            top: 0; 
            left: 0; 
            right: 0;
            bottom: 0;
            z-index: 1;
            display: block;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #hover-zone { position: fixed; top: 0; left: 0; width: 100%; height: 30px; z-index: 101; }
        #control-panel {
            position: fixed; top: -90px; left: 0; width: 100%; background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px); border-bottom: 1px solid #333; display: flex;
            justify-content: center; align-items: center; gap: 50px; flex-wrap: wrap;
            transition: top 0.4s ease; z-index: 100; padding: 15px 10px;
        }
        .ctrl { display: flex; flex-direction: column; align-items: center; color: #fff; }
        .ctrl label { font-size: 12px; margin-bottom: 5px; color: #0f0; text-transform: uppercase; letter-spacing: 1px; }
        .ctrl input[type=range] { width: 150px; cursor: pointer; accent-color: #0f0; }
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex;
            flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.95); color: #fff; z-index: 50; transition: opacity 0.5s; text-align: center; padding: 20px;
        }
        #fireworks-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 0;
        }
        #overlay > *:not(#fireworks-canvas) { position: relative; z-index: 1; }
        #overlay h1 { font-size: clamp(2rem, 8vw, 4rem); margin-bottom: 30px; color: #0f0; text-shadow: 0 0 20px #0f0; }
        .step { margin: 8px 0; font-size: clamp(14px, 3vw, 18px); color: #ccc; }
        .hl { color: #0f0; font-weight: bold; }
        .btn-action {
            padding: 15px 40px; font-size: clamp(16px, 4vw, 24px); background: transparent;
            border: 2px solid #0f0; color: #0f0; cursor: pointer; transition: all 0.3s;
            text-transform: uppercase; letter-spacing: 3px; margin-top: 15px;
        }
        .btn-action:hover { background: #0f0; color: #000; box-shadow: 0 0 30px #0f0; }
        .btn-secondary {
            border-color: #0af; color: #0af;
        }
        .btn-secondary:hover { background: #0af; color: #000; box-shadow: 0 0 30px #0af; }
        .btn-container { display: flex; flex-direction: column; gap: 10px; align-items: center; }
        .separator { color: #666; margin: 15px 0 5px 0; font-size: 14px; }
        #file-input { display: none; }
        #countdown {
            font-size: clamp(4rem, 15vw, 10rem);
            color: #0f0;
            text-shadow: 0 0 40px #0f0, 0 0 80px #0f0;
            margin: 30px 0;
            font-weight: bold;
            animation: pulse 1s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        .btn-container.disabled { opacity: 0.3; pointer-events: none; }
        #audio-controls {
            position: fixed; bottom: 50px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.85); backdrop-filter: blur(10px);
            border: 1px solid #333; border-radius: 10px; padding: 15px 25px;
            display: none; align-items: center; gap: 15px; z-index: 100;
        }
        #audio-controls.visible { display: flex; }
        .audio-btn {
            background: transparent; border: 1px solid #0af; color: #0af;
            width: 40px; height: 40px; border-radius: 50%; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.3s; font-size: 16px;
        }
        .audio-btn:hover { background: #0af; color: #000; }
        #progress-container {
            width: 200px; height: 6px; background: #333; border-radius: 3px;
            cursor: pointer; position: relative;
        }
        #progress-bar {
            height: 100%; background: #0af; border-radius: 3px; width: 0%;
            transition: width 0.1s linear;
        }
        #time-display { color: #888; font-size: 12px; min-width: 80px; text-align: center; }
        #volume-slider { width: 80px; accent-color: #0af; }
        #info { position: fixed; bottom: 15px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.3); font-size: 11px; z-index: 10; text-align: center; pointer-events: none; }
        .hidden { opacity: 0; pointer-events: none; }
        @media (max-width: 600px) {
            #control-panel { gap: 25px; padding: 10px; }
            .ctrl input[type=range] { width: 110px; }
            .ctrl label { font-size: 10px; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="hover-zone"></div>
    <div id="control-panel">
        <div class="ctrl">
            <label>Sensibilité</label>
            <input type="range" id="sens" min="0" max="3" step="0.1" value="1.5">
        </div>
        <div class="ctrl">
            <label>Vitesse</label>
            <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1.0">
        </div>
    </div>
    <div id="overlay">
        <canvas id="fireworks-canvas"></canvas>
        <h1>BUZZ RICKO</h1>
        <div style="color: #666; font-size: 12px; margin-top: -20px; margin-bottom: 20px;">v1.5</div>
        <div id="countdown">10</div>
        <div class="step">1. Cliquez sur le bouton ci-dessous</div>
        <div class="step">2. Sélectionnez l'<span class="hl">onglet ou l'écran</span> avec la musique</div>
        <div class="step">3. <span class="hl" style="text-decoration:underline;">Cochez "Partager l'audio"</span></div>
        <div class="btn-container disabled" id="btn-container">
            <button id="start-btn" class="btn-action">Connecter l'Audio</button>
            <div class="separator">— ou —</div>
            <button id="file-btn" class="btn-action btn-secondary">Charger un Fichier Audio</button>
            <input type="file" id="file-input" accept="audio/*">
        </div>
    </div>
    <div id="audio-controls">
        <button id="play-pause-btn" class="audio-btn">▶</button>
        <div id="progress-container">
            <div id="progress-bar"></div>
        </div>
        <span id="time-display">0:00 / 0:00</span>
        <input type="range" id="volume-slider" min="0" max="1" step="0.05" value="1">
    </div>
    <div id="canvas-container"></div>
    <div id="info">Double-cliquez: Plein Écran • Wormhole infini • Menu en haut</div>

    <script src="shader.js"></script>
    <script>
    // === FIREWORKS ANIMATION ===
    (function() {
        const fwCanvas = document.getElementById('fireworks-canvas');
        const fwCtx = fwCanvas.getContext('2d');
        const overlay = document.getElementById('overlay');

        function resizeFwCanvas() {
            fwCanvas.width = window.innerWidth;
            fwCanvas.height = window.innerHeight;
        }
        resizeFwCanvas();
        window.addEventListener('resize', resizeFwCanvas);

        const particles = [];
        const rockets = [];
        const colors = ['#0f0', '#0af', '#f0f', '#ff0', '#f50', '#0ff', '#fff'];

        class Particle {
            constructor(x, y, color, velocity, size, life) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.velocity = velocity;
                this.size = size;
                this.life = life;
                this.maxLife = life;
                this.gravity = 0.05;
                this.friction = 0.98;
            }

            update() {
                this.velocity.x *= this.friction;
                this.velocity.y *= this.friction;
                this.velocity.y += this.gravity;
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.life--;
            }

            draw() {
                const alpha = this.life / this.maxLife;
                fwCtx.save();
                fwCtx.globalAlpha = alpha;
                fwCtx.beginPath();
                fwCtx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
                fwCtx.fillStyle = this.color;
                fwCtx.shadowBlur = 15;
                fwCtx.shadowColor = this.color;
                fwCtx.fill();
                fwCtx.restore();
            }
        }

        class Rocket {
            constructor() {
                this.x = Math.random() * fwCanvas.width;
                this.y = fwCanvas.height;
                this.targetY = Math.random() * (fwCanvas.height * 0.5) + fwCanvas.height * 0.1;
                this.velocity = { x: (Math.random() - 0.5) * 2, y: -(Math.random() * 3 + 8) };
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.trail = [];
            }

            update() {
                this.trail.push({ x: this.x, y: this.y, alpha: 1 });
                if (this.trail.length > 10) this.trail.shift();

                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.velocity.y += 0.1;

                return this.y <= this.targetY || this.velocity.y >= 0;
            }

            draw() {
                // Draw trail
                this.trail.forEach((p, i) => {
                    const alpha = i / this.trail.length * 0.5;
                    fwCtx.beginPath();
                    fwCtx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                    fwCtx.fillStyle = this.color;
                    fwCtx.globalAlpha = alpha;
                    fwCtx.fill();
                });
                fwCtx.globalAlpha = 1;

                // Draw rocket
                fwCtx.beginPath();
                fwCtx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                fwCtx.fillStyle = this.color;
                fwCtx.shadowBlur = 10;
                fwCtx.shadowColor = this.color;
                fwCtx.fill();
            }

            explode() {
                const particleCount = 80 + Math.floor(Math.random() * 50);
                const explosionColor = this.color;
                const secondColor = colors[Math.floor(Math.random() * colors.length)];

                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 / particleCount) * i;
                    const speed = Math.random() * 6 + 2;
                    const useSecondColor = Math.random() > 0.7;

                    particles.push(new Particle(
                        this.x,
                        this.y,
                        useSecondColor ? secondColor : explosionColor,
                        { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed },
                        Math.random() * 3 + 1,
                        Math.random() * 60 + 40
                    ));
                }

                // Inner ring
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 / 20) * i;
                    const speed = Math.random() * 2 + 1;
                    particles.push(new Particle(
                        this.x,
                        this.y,
                        '#fff',
                        { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed },
                        Math.random() * 2 + 0.5,
                        Math.random() * 30 + 20
                    ));
                }
            }
        }

        let lastRocket = 0;
        const rocketInterval = 800;

        function animateFireworks(timestamp) {
            if (overlay.classList.contains('hidden')) {
                fwCtx.clearRect(0, 0, fwCanvas.width, fwCanvas.height);
                requestAnimationFrame(animateFireworks);
                return;
            }

            // Semi-transparent clear for trail effect
            fwCtx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            fwCtx.fillRect(0, 0, fwCanvas.width, fwCanvas.height);

            // Launch new rockets
            if (timestamp - lastRocket > rocketInterval) {
                rockets.push(new Rocket());
                if (Math.random() > 0.5) rockets.push(new Rocket()); // Sometimes launch 2
                lastRocket = timestamp;
            }

            // Update and draw rockets
            for (let i = rockets.length - 1; i >= 0; i--) {
                rockets[i].draw();
                if (rockets[i].update()) {
                    rockets[i].explode();
                    rockets.splice(i, 1);
                }
            }

            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }

            requestAnimationFrame(animateFireworks);
        }

        requestAnimationFrame(animateFireworks);
    })();

    // === MAIN APPLICATION ===
    (function() {
        const container = document.getElementById('canvas-container');
        const overlay = document.getElementById('overlay');
        const panel = document.getElementById('control-panel');
        const hoverZone = document.getElementById('hover-zone');
        const sensSlider = document.getElementById('sens');
        const speedSlider = document.getElementById('speed');
        const startBtn = document.getElementById('start-btn');
        const fileBtn = document.getElementById('file-btn');
        const fileInput = document.getElementById('file-input');
        const audioControls = document.getElementById('audio-controls');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const timeDisplay = document.getElementById('time-display');
        const volumeSlider = document.getElementById('volume-slider');
        const countdownEl = document.getElementById('countdown');
        const btnContainer = document.getElementById('btn-container');

        // Countdown de 10 secondes
        let countdownValue = 10;
        const countdownInterval = setInterval(() => {
            countdownValue--;
            if (countdownValue > 0) {
                countdownEl.textContent = countdownValue;
            } else {
                countdownEl.textContent = 'GO!';
                btnContainer.classList.remove('disabled');
                clearInterval(countdownInterval);
                setTimeout(() => {
                    countdownEl.style.display = 'none';
                }, 1000);
            }
        }, 1000);

        let audioCtx, analyser, dataArr, audioActive = false;
        let bass = 0, treble = 0;
        let timeout;
        let audioElement = null;
        let audioSource = null;
        let isPlaying = false;

        function showPanel() {
            panel.style.top = '0';
            clearTimeout(timeout);
            timeout = setTimeout(() => panel.style.top = '-90px', 3000);
        }
        hoverZone.onmouseenter = showPanel;
        panel.onmouseenter = showPanel;
        panel.onmousemove = showPanel;

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 512;
                audioCtx.createMediaStreamSource(stream).connect(analyser);
                dataArr = new Uint8Array(analyser.frequencyBinCount);
                audioActive = true;
                overlay.classList.add('hidden');
                stream.getVideoTracks()[0].onended = () => { overlay.classList.remove('hidden'); audioActive = false; };
            } catch (e) { alert("Erreur: Avez-vous coché 'Partager l'audio'? " + e.message); }
        }
        startBtn.onclick = initAudio;

        // File audio handling
        fileBtn.onclick = () => fileInput.click();

        fileInput.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                // Create audio context if needed
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Resume audio context if suspended
                if (audioCtx.state === 'suspended') {
                    await audioCtx.resume();
                }

                // Create audio element
                if (audioElement) {
                    audioElement.pause();
                    audioElement.src = '';
                }

                audioElement = new Audio();
                audioElement.src = URL.createObjectURL(file);
                audioElement.volume = volumeSlider.value;

                // Setup analyser
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 512;
                dataArr = new Uint8Array(analyser.frequencyBinCount);

                // Connect audio element to analyser
                if (audioSource) {
                    audioSource.disconnect();
                }
                audioSource = audioCtx.createMediaElementSource(audioElement);
                audioSource.connect(analyser);
                analyser.connect(audioCtx.destination);

                // Start playback
                await audioElement.play();
                isPlaying = true;
                audioActive = true;
                playPauseBtn.textContent = '⏸';

                // Show controls, hide overlay
                overlay.classList.add('hidden');
                audioControls.classList.add('visible');

                // Update progress
                audioElement.ontimeupdate = () => {
                    const progress = (audioElement.currentTime / audioElement.duration) * 100;
                    progressBar.style.width = `${progress}%`;
                    timeDisplay.textContent = `${formatTime(audioElement.currentTime)} / ${formatTime(audioElement.duration)}`;
                };

                // Handle end of track
                audioElement.onended = () => {
                    isPlaying = false;
                    playPauseBtn.textContent = '▶';
                };

            } catch (e) {
                alert("Erreur lors du chargement du fichier audio: " + e.message);
            }
        };

        // Play/Pause control
        playPauseBtn.onclick = () => {
            if (!audioElement) return;

            if (isPlaying) {
                audioElement.pause();
                playPauseBtn.textContent = '▶';
            } else {
                audioElement.play();
                playPauseBtn.textContent = '⏸';
            }
            isPlaying = !isPlaying;
        };

        // Progress bar seeking
        progressContainer.onclick = (e) => {
            if (!audioElement) return;
            const rect = progressContainer.getBoundingClientRect();
            const pos = (e.clientX - rect.left) / rect.width;
            audioElement.currentTime = pos * audioElement.duration;
        };

        // Volume control
        volumeSlider.oninput = () => {
            if (audioElement) {
                audioElement.volume = volumeSlider.value;
            }
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(0x000000, 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            uBass: { value: 0 },
            uMid: { value: 0 },
            uTreble: { value: 0 },
            uSensitivity: { value: 1.5 },
            uSpeed: { value: 1.0 }
        };

        const mat = new THREE.ShaderMaterial({ vertexShader, fragmentShader, uniforms });
        scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat));

        function animate(t) {
            requestAnimationFrame(animate);
            const s = t * 0.001;

            if (audioActive && analyser) {
                analyser.getByteFrequencyData(dataArr);
                let b = 0, tr = 0;
                for (let i = 0; i < 10; i++) b += dataArr[i];
                for (let i = 50; i < 100; i++) tr += dataArr[i];
                bass += ((b / 10 / 255) - bass) * 0.15;
                treble += ((tr / 50 / 255) - treble) * 0.15;
            }

            uniforms.iTime.value = s;
            uniforms.uBass.value = bass;
            uniforms.uTreble.value = treble;
            uniforms.uSensitivity.value = parseFloat(sensSlider.value);
            uniforms.uSpeed.value = parseFloat(speedSlider.value);
            renderer.render(scene, camera);
        }
        animate(0);

        window.onresize = () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
        };

        window.ondblclick = () => {
            if (!document.fullscreenElement) document.body.requestFullscreen();
            else document.exitFullscreen();
        };
    })();
    </script>
</body>
</html>
